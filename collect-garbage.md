---
title: "javascript中的垃圾回收"
date: "2020-09-23"
name: 'francis'
age: '24'
tags: [JavaScript回顾]
categories: JavaScript
---
# javascript中的垃圾回收

- javascript中的垃圾回收历史有两种，一种是最常用的标记清除，一种是不常用的引用计数清除法。

## 标记清除

- 标记清除是现代浏览器最常用的垃圾回收方式，原理是：
- 当上下文有变量进入的时候就为它添加一个标记，这样整个程序执行时每一个创建的变量都会被添加标记。当变量离开上下文时也会被加上离开上下文的标记。然后当垃圾回收进程执行时，会把当前上下文的所有变量跟被引用的变量去除标记，这样剩下的有标记就都是不被引用也不被使用的变量了，这样就可以做内存清理了，销毁带标记的值并回收内存。

## 引用计数清除

- 这种计数方式在早期浏览器有使用过，后面就基本不怎么使用了，原理如下：
- 当一个值被赋值给一个变量时就会把该值的引用数加一。比如，当声明一个变量并引用该值，则该值的引用数加一，当这个值被赋给另一个变量时，引用数继续加一。当一个引用该值的变量被其他值覆盖了，则该值的引用数减一，当引用数为0则表示该值不可被访问了，就会被垃圾回收。
- 该方式不常用是因为在循环引用时会无法释放内存，比如当a是一个对象，b也是一个对象，a的某个属性指向了b，b的某个属性指向了a，这样他们的引用值一直都不会为0，也就导致了该值一直存在无法回收。只有当我们显示的将a对应的属性跟b对应的属性都赋值null才会让他们进入垃圾回收。
<!--more-->
## 性能优化

- 现代浏览器的垃圾回收都是按照已分配对象的大小跟数量来判断的，这是因为早期IE是根据分配数来进行垃圾回收，比如设定了256个变量或者64k的字符串等，当满足其中的条件就会进行回收，这有可能整个脚本始终存在这么多的变量就导致了一直在运行，严重影响性能。
- 所以改为了现有的根据分配对象来进行，首先它的起始阈值跟之前是一致的，只不过当某次垃圾回收的内存不到已分配的15%，那么就说明程序过大，这个阈值不够了，就会对阈值进行翻倍，然后下一次如果还是不到15%就继续翻倍，直到它满足15%以上为止
- 如果某次的内存已经达到了85%，说明这个阈值已经过大了，应该再频繁一点，然后就会重置为默认值，重复进行这两个步骤，这样我们的性能就有很好的提升
- 对声明的全局变量要是不再使用应该置为null
- 多使用let、const提升性能，因为都是块级作用域，肯定会比全局变量更早终止，也就有可能更早的被回收

## 隐藏类优化性能

- 当我们的两个对象共享一个构造函数与原型时，在v8引擎会默认两个实例引用同一个隐藏类，如下：

```js
function Article(){
  this.title = "my name"
}
let a1 = new Article()
let a2 = new Article()
```

- 这种情况下会默认使用一个隐藏类，但是当我们对对象进行了删除或者新增属性就会打破这个规则，如下

```js
// 新增属性
function Article(){
  this.title = "my name"
}
let a1 = new Article()
let a2 = new Article()
a2.name = 'danny'

// 删除属性
function Article(){
  this.title = "my name"
}
let a1 = new Article()
let a2 = new Article()
delete a2.title
```

- 这两种情况都会导致不再共享一个隐藏类，对应两个隐藏类，如果隐藏类过大就会影响性能，我们可以进行下面的优化
- 对需要新增的属性操作添加在原型内，如下

```js
function Article(name){
  this.title = "my name"
  this.name = name
}
let a1 = new Article()
let a2 = new Article('danny')
```

- 这样还是共用一个隐藏类，针对删除操作，我们不要显示的删除，只需要将值设为null即可，如下

```js
function Article(){
  this.title = "my name"
}
let a1 = new Article()
let a2 = new Article()
a2.title = null
```