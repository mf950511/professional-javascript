---
title: "不常用的一元操作符"
date: "2020-09-17"
name: 'francis'
age: '24'
tags: [JavaScript回顾]
categories: JavaScript
---

# 不常用的一元操作符

## 位操作符

- ECMAScript中数值都是已64位格式存储，但是位操作符不能直接在64位中操作，要把值转为32位整数，操作完成后再转为64位整数。
- 对开发者来说，是不用关注64位整数的，我们感知不到，我们只需要知道32位整数的工作原理即可
- 有符号整数由一位符号位与31位二进制数值位来表示。第一位的符号位0表示正数，1表示负数。其他的数决定这个数的大小，数值跟二进制转十进制的方式相同，从最后一位开始，第一个代表2的0次方，第二个代表2的一次方，没有实际值的按0来填充。比如18按32位来表示为

```js
00000000000000000000000000010010 // 32位表示18
//转换方式
(Math.pow(2, 0)) * 0 + (Math.pow(2, 1)) * 1 + (Math.pow(2, 2)) * 0 + (Math.pow(2, 3)) * 0 + (Math.pow(2, 4)) * 1
```

- 负数也是用二进制来表示，但是跟正数不一样，负数的表示是对应32位正数的补码。有三个步骤
- 第一步，写出该负数的绝对值对应的32位数
- 第二步，将32位数中的0变为1，1变为0
- 第三步，在第二步得到的数上加1，然后逢二进一，比如-18的表示
<!--more-->
```js
// 1.写出绝对值，也就是18的32位数
00000000000000000000000000010010
// 2.将0变为1，1变为0
11111111111111111111111111101101
// 3.在第二步的基础上加1
11111111111111111111111111101110 // -18的32位表现形式

```

- ECMAScript会尽量的将这些数据都给你保留，当你使用toString并指定二进制数值时，会返回'-10010'来给你

```js
let num = -18
console.log(num.toString(2)) // '-10010'

```

- 上面是有符号正数，当我们用来表示无符号整数是，第一位就不再是符号位，也是真正的数值位，所以无符号整数可以比有符号整数大一点
- 在ECMAScript中使用位运算时，会先将64位整数转为32位正数，然后进行位运算，然后转为64位整数，这也就给我们一个错觉，我们在操作真正的32位正数。这也使得对二进制的操作与其他语言相似。
- 在这个处理中有两个特殊值NaN跟Infinity会跟0的处理方式一样
- 如果为非数值类型使用位操作符则会使用Number()强制转为数值，然后计算

## Not操作符(~)

- 简单的返回一个数对应32位数的补码（即0变为1，1变为0）

```js
let num = 25 
// 对应的32位数
000000000000000000000000000011001
// 使用位操作符
111111111111111111111111111100110
// 然后将32位数转为对应的负数，将之前的三步倒过来
// 1.减1
111111111111111111111111111100101
// 2. 取补码
000000000000000000000000000011010
// 3.计算值并加负号
-26
```

- 所以我们在对25进行了~操作后就得到了-26
- 其实，~操作的结果就是我们对要操作的数进行取反，然后减1即可
- 位操作符因为操作数值的最低级别，所以速度极快

## AND操作符(&)

- 该符号工作于两个值，将两个值对应的位进行操作，只有当两个值对应位都是1才返回1，否则返回0，如下

```js
let result = 25 & 3
// 25的32位数
000000000000000000000000000011001
// 3的32位数
000000000000000000000000000000011
// 对应值
000000000000000000000000000000001
// 转为整数就是1
console.log(result) // 1

```

## OR操作符(|)

- 该符号同样作用于两个值，对两个值的为进行操作，只有当两个值对应位都是0才返回0，否则返回1，如下

```js
let result = 25 | 3
// 25的32位数
000000000000000000000000000011001
// 3的32位数
000000000000000000000000000000011
// 对应值
000000000000000000000000000011011
// 转换为整数就是 27
console.log(result) // 27
```

## XOR操作符(^)

- 同样作用与两个值，将两个数的32位数进行比较，当相同时返回0，不同时返回1，比如 0跟0返回0，1跟1返回0， 1跟0返回1，0跟1返回1，如下

```js
let result = 25 | 3
// 25的32位数
000000000000000000000000000011001
// 3的32位数
000000000000000000000000000000011
// 对应值
000000000000000000000000000011010
// 转换为整数就是 26
console.log(result) // 26
```

## 左移操作

- 左移操作由两个 < 表示，并且将除符号位之外所有的位数向左移动指定的位数，比如对2进行左移5操作，如下

```js
let val = 2
let newVal = val << 5
// 首先将2转为32位数
000000000000000000000000000000010
// 然后将除符号位的数向左移动5位
0000000000000000000000000010
// 然后把后面空出来的用0补起来
000000000000000000000000001000000
// 最终得到  64
console.log(newVal) // 64
```

- 左移操作不会修改符号位，所以对-2进行左移5位得到的是-64而不是64

## 有符号右移操作

- 有符号右移使用两个 > 然后跟一个移动数量来表示，比如对64进行右移5操作，如下

```js
let val = 64
let newVal = val >> 5
// 首先将64转为32位数
000000000000000000000000001000000
// 然后将除符号位的数向右移动5位
0     000000000000000000000000010
// 然后把前面空出来的用0补起来
000000000000000000000000000000010
// 最终得到  2
console.log(newVal) // 2
```

- 有符号右移操作同样不会修改符号位，所以对-64进行右移5位得到的是-2而不是2

## 无符号右移操作

- 无符号右移操作是使用三个 > 然后跟一个右移数量表示，因为是无符号数，所以32位都表示数值，也就不会对第一位进行保留了
- 这种情况下对正数进行右移并不会改变原来的值，因为符号位本来就是0，如下

```js
let val = 64
let newVal = val >> 5
// 首先将64转为32位数
000000000000000000000000001000000
// 然后将所有数向右移动5位
     0000000000000000000000000010
// 然后把前面空出来的用0补起来
000000000000000000000000000000010
// 最终得到  2
console.log(newVal) // 2
```

- 但是针对负数就不一样了，因为负数是对应正数取补码加1，所以表现形式不一致，比如-64，如下

```js
let val = -64
let newVal = val >>> 5
// 首先将-64转为32位数
111111111111111111111111111000000
// 然后将所有数向右移动5位
     1111111111111111111111111110
// 然后把前面空出来的用0补起来
000001111111111111111111111111110
// 最终得到  134217726
console.log(newVal) // 134217726
```

## 逻辑与(&&)

- 同样作用于两个值，类型无要求返回逻辑如下
- 两个都是boolean值，则只有两个都是true才返回true，否则返回false
- 如果第一个是对象，则一定返回第二个值
- 如果第二个是对象，则只有第一个为true时才返回这个对象
- 两个都是对象，则返回第二个对象
- 两个中有一个null，返回null
- 两个中有一个NaN，返回NaN
- 两个中有一个undefined，返回undefined
- 如果两个为undefined、null、NaN中的两个则第一个是什么就返回什么
- &&为短路操作符，第一个为false，则第二个永远不会执行，如下


## 逻辑或(||)

- 同样作用与两个值，类型无要求
- 两个都是boolean值，则只有两个都是false才返回false，否则返回true
- 如果第一个是对象，则返回第一个
- 如果第一个是false，则返回第二个
- 两个都是对象，返回第一个
- 两个都是null，返回null
- 两个都是undefined，返回undefined
- 两个都是NaN，返回NaN
- ||也是短路操作符，第一个为true，则第二个不执行